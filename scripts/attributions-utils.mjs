import { readFile } from "node:fs/promises";

export const README_ATTRIBUTIONS_START = "<!-- ATTRIBUTIONS:START -->";
export const README_ATTRIBUTIONS_END = "<!-- ATTRIBUTIONS:END -->";

function normalizeRepositoryUrl(value) {
  if (typeof value !== "string" || value.trim().length === 0) {
    return "";
  }
  let normalized = value.trim();
  if (normalized.startsWith("git+")) {
    normalized = normalized.slice(4);
  }
  if (normalized.startsWith("git@github.com:")) {
    normalized = `https://github.com/${normalized.slice("git@github.com:".length)}`;
  }
  if (normalized.startsWith("github:")) {
    normalized = `https://github.com/${normalized.slice("github:".length)}`;
  }
  if (normalized.endsWith(".git")) {
    normalized = normalized.slice(0, -4);
  }
  return normalized;
}

function toProjectUrl(pkg) {
  if (typeof pkg.homepage === "string" && pkg.homepage.trim().length > 0) {
    return pkg.homepage.trim();
  }
  if (typeof pkg.repository === "string") {
    return normalizeRepositoryUrl(pkg.repository);
  }
  if (pkg.repository && typeof pkg.repository.url === "string") {
    return normalizeRepositoryUrl(pkg.repository.url);
  }
  return "";
}

export async function loadJson(path) {
  const raw = await readFile(path, "utf8");
  return JSON.parse(raw);
}

export async function collectDirectLibraries() {
  const projectPackageJson = await loadJson("package.json");
  const directDependencyNames = Array.from(
    new Set([
      ...Object.keys(projectPackageJson.dependencies ?? {}),
      ...Object.keys(projectPackageJson.devDependencies ?? {})
    ])
  ).sort((left, right) => left.localeCompare(right));

  const libraries = [];
  for (const dependencyName of directDependencyNames) {
    const dependencyPackageJson = await loadJson(`node_modules/${dependencyName}/package.json`);
    const url = toProjectUrl(dependencyPackageJson);
    libraries.push({
      name: dependencyName,
      version: String(dependencyPackageJson.version ?? "unknown"),
      license: String(dependencyPackageJson.license ?? "unknown"),
      url
    });
  }
  return libraries;
}

export function buildAttributionsMarkdown({ source, generatedLibraries }) {
  const lines = [];
  lines.push("## Attributions");
  lines.push("");
  lines.push("This section is generated by `npm run attributions:sync`. Do not edit this block manually.");
  lines.push("");
  lines.push("### APIs and Services");
  lines.push("");
  for (const service of source.services) {
    lines.push(`- **${service.name}**: ${service.purpose}`);
    lines.push(`  - Service: ${service.url}`);
    lines.push(`  - Terms: ${service.termsUrl}`);
    if (typeof service.requiredNotice === "string" && service.requiredNotice.trim().length > 0) {
      lines.push(`  - Required notice: ${service.requiredNotice}`);
    }
    if (typeof service.notes === "string" && service.notes.trim().length > 0) {
      lines.push(`  - Notes: ${service.notes}`);
    }
  }
  lines.push("");
  lines.push("### Resources");
  lines.push("");
  for (const resource of source.resources) {
    lines.push(`- **${resource.name}**: ${resource.purpose}`);
    lines.push(`  - Link: ${resource.url}`);
    if (typeof resource.notes === "string" && resource.notes.trim().length > 0) {
      lines.push(`  - Notes: ${resource.notes}`);
    }
  }
  lines.push("");
  lines.push("### Open Source Libraries (Direct Dependencies)");
  lines.push("");
  for (const library of generatedLibraries.libraries) {
    const urlText = library.url && library.url.trim().length > 0 ? library.url : "N/A";
    lines.push(`- ${library.name} @ ${library.version} (${library.license}) - ${urlText}`);
  }
  lines.push("");
  lines.push(`Generated at: ${generatedLibraries.generatedAt}`);
  lines.push("");
  lines.push(
    "EVE Online and the EVE logo are the registered trademarks of CCP hf. All rights are reserved worldwide."
  );
  lines.push("This application is not endorsed by CCP.");
  lines.push("");
  return lines.join("\n");
}

export function injectReadmeAttributionsBlock(readmeContent, markdownSection) {
  const startMarkerIndex = readmeContent.indexOf(README_ATTRIBUTIONS_START);
  const endMarkerIndex = readmeContent.indexOf(README_ATTRIBUTIONS_END);
  const sectionWithMarkers = `${README_ATTRIBUTIONS_START}\n${markdownSection}${README_ATTRIBUTIONS_END}`;

  if (startMarkerIndex === -1 || endMarkerIndex === -1 || endMarkerIndex < startMarkerIndex) {
    const trimmed = readmeContent.trimEnd();
    return `${trimmed}\n\n${sectionWithMarkers}\n`;
  }

  const before = readmeContent.slice(0, startMarkerIndex);
  const after = readmeContent.slice(endMarkerIndex + README_ATTRIBUTIONS_END.length);
  return `${before}${sectionWithMarkers}${after}`;
}
